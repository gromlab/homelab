# =====================================================================
# ESPHome Package: Floor Heating Relay Controller
# =====================================================================
# Device: LILYGO T-Relay ESP32 4-Channel Relay Module
# Purpose: Control 4 radiant heating zones via 24VAC solenoid valves
#          Responds to 2-wire battery thermostats for each zone
#          Monitors boiler supply pipe temperature via Dallas sensor
#          Includes per-zone manual bypass mode for independent override control
#
# NOTE: All secrets (WiFi, API key, OTA password, AP password) are
#       managed in your main config file (floorheatingrelay.yaml).
#       This package only references them via !secret directives.
# =====================================================================

substitutions:
  # Device identification
  device_name: floorheatingrelay
  friendly_name: Floor Heating Relay
  device_area: Basement
  
  # =====================================================================
  # GENERIC ZONE NAMES - Override in your main config
  # =====================================================================
  zone_1_name: Zone 1
  zone_2_name: Zone 2
  zone_3_name: Zone 3
  zone_4_name: Zone 4
  
  # =====================================================================
  # RELAY GPIO PINS (T-Relay hardware mapping)
  # =====================================================================
  relay_zone_1_pin: GPIO21
  relay_zone_2_pin: GPIO19
  relay_zone_3_pin: GPIO18
  relay_zone_4_pin: GPIO05
  
  # =====================================================================
  # THERMOSTAT INPUT GPIO PINS
  # =====================================================================
  thermostat_zone_1_pin: GPIO27
  thermostat_zone_2_pin: GPIO26
  thermostat_zone_3_pin: GPIO13
  thermostat_zone_4_pin: GPIO23
  
  # =====================================================================
  # SENSOR PINS
  # =====================================================================
  temperature_sensor_pin: GPIO14
  status_led_pin: GPIO25
  
  # =====================================================================
  # FILTER & UPDATE INTERVALS
  # =====================================================================
  debounce_time: 100ms
  api_reboot_timeout: 15min

# =====================================================================
# ESPHOME CORE CONFIGURATION
# =====================================================================
esphome:
  name: ${device_name}
  friendly_name: ${friendly_name}
  comment: "Radiant floor heating zone controller - 4 valve management + per-zone manual bypass"
  area: ${device_area}
  
  # Boot-time startup sequence to ensure safe state and sync with thermostats
  on_boot:
    priority: -100  # Execute after all components initialize
    then:
      - delay: 2s   # Allow GPIO stabilization
      # Force all relays off first
      - switch.turn_off: relay_zone_1
      - switch.turn_off: relay_zone_2
      - switch.turn_off: relay_zone_3
      - switch.turn_off: relay_zone_4
      # Disable all zone bypasses on boot (safety default)
      - switch.turn_off: bypass_zone_1
      - switch.turn_off: bypass_zone_2
      - switch.turn_off: bypass_zone_3
      - switch.turn_off: bypass_zone_4
      # Check thermostat states and activate relays if any are calling for heat
      - if:
          condition:
            binary_sensor.is_on: thermostat_zone_1
          then:
            - switch.turn_on: relay_zone_1
            - logger.log:
                format: "Boot: ${zone_1_name} thermostat was calling heat - relay activated"
                level: INFO
      - if:
          condition:
            binary_sensor.is_on: thermostat_zone_2
          then:
            - switch.turn_on: relay_zone_2
            - logger.log:
                format: "Boot: ${zone_2_name} thermostat was calling heat - relay activated"
                level: INFO
      - if:
          condition:
            binary_sensor.is_on: thermostat_zone_3
          then:
            - switch.turn_on: relay_zone_3
            - logger.log:
                format: "Boot: ${zone_3_name} thermostat was calling heat - relay activated"
                level: INFO
      - if:
          condition:
            binary_sensor.is_on: thermostat_zone_4
          then:
            - switch.turn_on: relay_zone_4
            - logger.log:
                format: "Boot: ${zone_4_name} thermostat was calling heat - relay activated"
                level: INFO

# =====================================================================
# LOGGING CONFIGURATION
# =====================================================================
logger:
  level: INFO  # Use INFO for normal operation, DEBUG for troubleshooting

# =====================================================================
# HOME ASSISTANT API INTEGRATION
# =====================================================================
# Secrets managed in: floorheatingrelay.yaml
#   - floor_heating_relay_api_key: Encryption key (add to ESPHome Secrets)
api:
  encryption:
    key: !secret floor_heating_relay_api_key
  reboot_timeout: ${api_reboot_timeout}

# =====================================================================
# OVER-THE-AIR FIRMWARE UPDATES
# =====================================================================
# Secrets managed in: floorheatingrelay.yaml
#   - floor_heating_relay_ota_password: OTA update password (add to ESPHome Secrets)
ota:
  platform: esphome
  password: !secret floor_heating_relay_ota_password

# =====================================================================
# WIFI CONFIGURATION
# =====================================================================
# Secrets managed in: floorheatingrelay.yaml
#   - wifi_ssid: Your WiFi network name (add to ESPHome Secrets)
#   - wifi_password: Your WiFi password (add to ESPHome Secrets)
#   - floor_heating_relay_ap_password: Fallback hotspot password (add to ESPHome Secrets)
wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password
  
  # Fallback captive portal if WiFi fails
  ap:
    ssid: "${friendly_name} Hotspot"
    password: !secret floor_heating_relay_ap_password

# =====================================================================
# CAPTIVE PORTAL - Enables configuration via fallback WiFi hotspot
# =====================================================================
captive_portal:

# =====================================================================
# GLOBALS - State variables for per-zone manual bypass logic
# =====================================================================
globals:
  # Timeout duration in milliseconds (updated by number slider)
  # Default: 2 hours = 7200000 ms - applies to all zone bypasses
  - id: bypass_timeout_ms
    type: unsigned long
    restore_value: no
    initial_value: '7200000'
  
  # Tracks when each zone's bypass was enabled (milliseconds since boot)
  - id: bypass_enable_time_zone_1
    type: unsigned long
    restore_value: no
    initial_value: '0'
  - id: bypass_enable_time_zone_2
    type: unsigned long
    restore_value: no
    initial_value: '0'
  - id: bypass_enable_time_zone_3
    type: unsigned long
    restore_value: no
    initial_value: '0'
  - id: bypass_enable_time_zone_4
    type: unsigned long
    restore_value: no
    initial_value: '0'

# =====================================================================
# ONE-WIRE BUS FOR DALLAS TEMPERATURE SENSOR
# =====================================================================
one_wire:
  - platform: gpio
    pin: ${temperature_sensor_pin}

# =====================================================================
# SENSORS
# =====================================================================
sensor:
  # Dallas DS18B20 temperature sensor on boiler pipe
  - platform: dallas_temp
    address: 0x353ce1d44393b928
    name: "Boiler Supply Temperature"
    id: boiler_temp
    icon: "mdi:thermometer-high"
    unit_of_measurement: "Â°C"
    accuracy_decimals: 1
    update_interval: 10s
    filters:
      - sliding_window_moving_average:
          window_size: 5
          send_every: 1
  
  # Template sensors: time remaining on manual bypass per zone
  - platform: template
    name: "${zone_1_name} Bypass Time Remaining"
    id: bypass_time_remaining_zone_1
    icon: "mdi:timelapse"
    unit_of_measurement: "min"
    accuracy_decimals: 0
    update_interval: 10s
    lambda: |-
      if (!id(bypass_zone_1).state) {
        return 0;
      }
      unsigned long elapsed = millis() - id(bypass_enable_time_zone_1);
      unsigned long remaining_ms = (id(bypass_timeout_ms) > elapsed) ? (id(bypass_timeout_ms) - elapsed) : 0;
      return (float)remaining_ms / 60000.0;
  
  - platform: template
    name: "${zone_2_name} Bypass Time Remaining"
    id: bypass_time_remaining_zone_2
    icon: "mdi:timelapse"
    unit_of_measurement: "min"
    accuracy_decimals: 0
    update_interval: 10s
    lambda: |-
      if (!id(bypass_zone_2).state) {
        return 0;
      }
      unsigned long elapsed = millis() - id(bypass_enable_time_zone_2);
      unsigned long remaining_ms = (id(bypass_timeout_ms) > elapsed) ? (id(bypass_timeout_ms) - elapsed) : 0;
      return (float)remaining_ms / 60000.0;
  
  - platform: template
    name: "${zone_3_name} Bypass Time Remaining"
    id: bypass_time_remaining_zone_3
    icon: "mdi:timelapse"
    unit_of_measurement: "min"
    accuracy_decimals: 0
    update_interval: 10s
    lambda: |-
      if (!id(bypass_zone_3).state) {
        return 0;
      }
      unsigned long elapsed = millis() - id(bypass_enable_time_zone_3);
      unsigned long remaining_ms = (id(bypass_timeout_ms) > elapsed) ? (id(bypass_timeout_ms) - elapsed) : 0;
      return (float)remaining_ms / 60000.0;
  
  - platform: template
    name: "${zone_4_name} Bypass Time Remaining"
    id: bypass_time_remaining_zone_4
    icon: "mdi:timelapse"
    unit_of_measurement: "min"
    accuracy_decimals: 0
    update_interval: 10s
    lambda: |-
      if (!id(bypass_zone_4).state) {
        return 0;
      }
      unsigned long elapsed = millis() - id(bypass_enable_time_zone_4);
      unsigned long remaining_ms = (id(bypass_timeout_ms) > elapsed) ? (id(bypass_timeout_ms) - elapsed) : 0;
      return (float)remaining_ms / 60000.0;

# =====================================================================
# NUMBER COMPONENT - Timeout control for manual bypass (shared across all zones)
# =====================================================================
number:
  - platform: template
    name: "Manual Bypass Timeout"
    id: bypass_timeout_hours
    icon: "mdi:timer"
    unit_of_measurement: "h"
    min_value: 1
    max_value: 8
    step: 1
    optimistic: true
    restore_value: true
    initial_value: 2
    on_value:
      then:
        - globals.set:
            id: bypass_timeout_ms
            value: !lambda return (unsigned long)(x * 3600000);
        - logger.log:
            format: "Manual bypass timeout updated to %.0f hours"
            args: ["x"]
            level: INFO

# =====================================================================
# RELAY SWITCHES - GPIO controlled outputs for solenoid valves
# =====================================================================
switch:
  # PER-ZONE BYPASS SWITCHES
  
  - platform: template
    name: "${zone_1_name} Zone Bypass"
    id: bypass_zone_1
    icon: "mdi:lock-open"
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_on_action:
      - logger.log:
          format: "${zone_1_name} bypass ENABLED - thermostat ignored, HA control active"
          level: WARN
      - globals.set:
          id: bypass_enable_time_zone_1
          value: !lambda return millis();
    turn_off_action:
      - logger.log:
          format: "${zone_1_name} bypass DISABLED - syncing relay to thermostat state"
          level: INFO
      - globals.set:
          id: bypass_enable_time_zone_1
          value: '0'
      - if:
          condition:
            binary_sensor.is_on: thermostat_zone_1
          then:
            - switch.turn_on: relay_zone_1
          else:
            - switch.turn_off: relay_zone_1
  
  - platform: template
    name: "${zone_2_name} Zone Bypass"
    id: bypass_zone_2
    icon: "mdi:lock-open"
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_on_action:
      - logger.log:
          format: "${zone_2_name} bypass ENABLED - thermostat ignored, HA control active"
          level: WARN
      - globals.set:
          id: bypass_enable_time_zone_2
          value: !lambda return millis();
    turn_off_action:
      - logger.log:
          format: "${zone_2_name} bypass DISABLED - syncing relay to thermostat state"
          level: INFO
      - globals.set:
          id: bypass_enable_time_zone_2
          value: '0'
      - if:
          condition:
            binary_sensor.is_on: thermostat_zone_2
          then:
            - switch.turn_on: relay_zone_2
          else:
            - switch.turn_off: relay_zone_2
  
  - platform: template
    name: "${zone_3_name} Zone Bypass"
    id: bypass_zone_3
    icon: "mdi:lock-open"
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_on_action:
      - logger.log:
          format: "${zone_3_name} bypass ENABLED - thermostat ignored, HA control active"
          level: WARN
      - globals.set:
          id: bypass_enable_time_zone_3
          value: !lambda return millis();
    turn_off_action:
      - logger.log:
          format: "${zone_3_name} bypass DISABLED - syncing relay to thermostat state"
          level: INFO
      - globals.set:
          id: bypass_enable_time_zone_3
          value: '0'
      - if:
          condition:
            binary_sensor.is_on: thermostat_zone_3
          then:
            - switch.turn_on: relay_zone_3
          else:
            - switch.turn_off: relay_zone_3
  
  - platform: template
    name: "${zone_4_name} Zone Bypass"
    id: bypass_zone_4
    icon: "mdi:lock-open"
    restore_mode: RESTORE_DEFAULT_OFF
    optimistic: true
    turn_on_action:
      - logger.log:
          format: "${zone_4_name} bypass ENABLED - thermostat ignored, HA control active"
          level: WARN
      - globals.set:
          id: bypass_enable_time_zone_4
          value: !lambda return millis();
    turn_off_action:
      - logger.log:
          format: "${zone_4_name} bypass DISABLED - syncing relay to thermostat state"
          level: INFO
      - globals.set:
          id: bypass_enable_time_zone_4
          value: '0'
      - if:
          condition:
            binary_sensor.is_on: thermostat_zone_4
          then:
            - switch.turn_on: relay_zone_4
          else:
            - switch.turn_off: relay_zone_4
  
  # RELAY SWITCHES - GPIO controlled outputs for solenoid valves
  
  - platform: gpio
    pin: ${relay_zone_1_pin}
    id: relay_zone_1
    name: "Heat ${zone_1_name} Valve"
    icon: "mdi:pipe-valve"
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - logger.log:
          format: "${zone_1_name} heating valve opened"
          level: INFO
    on_turn_off:
      - logger.log:
          format: "${zone_1_name} heating valve closed"
          level: INFO
  
  - platform: gpio
    pin: ${relay_zone_2_pin}
    id: relay_zone_2
    name: "Heat ${zone_2_name} Valve"
    icon: "mdi:pipe-valve"
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - logger.log:
          format: "${zone_2_name} heating valve opened"
          level: INFO
    on_turn_off:
      - logger.log:
          format: "${zone_2_name} heating valve closed"
          level: INFO
  
  - platform: gpio
    pin: ${relay_zone_3_pin}
    id: relay_zone_3
    name: "Heat ${zone_3_name} Valve"
    icon: "mdi:pipe-valve"
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - logger.log:
          format: "${zone_3_name} heating valve opened"
          level: INFO
    on_turn_off:
      - logger.log:
          format: "${zone_3_name} heating valve closed"
          level: INFO
  
  - platform: gpio
    pin: ${relay_zone_4_pin}
    id: relay_zone_4
    name: "Heat ${zone_4_name} Valve"
    icon: "mdi:pipe-valve"
    restore_mode: ALWAYS_OFF
    on_turn_on:
      - logger.log:
          format: "${zone_4_name} heating valve opened"
          level: INFO
    on_turn_off:
      - logger.log:
          format: "${zone_4_name} heating valve closed"
          level: INFO

# =====================================================================
# BINARY SENSORS - GPIO inputs from thermostats
# =====================================================================

binary_sensor:
  # ZONE 1 THERMOSTAT INPUT
  - platform: gpio
    pin:
      number: ${thermostat_zone_1_pin}
      mode: INPUT_PULLUP
      inverted: true
    name: "${zone_1_name} Thermostat Call"
    id: thermostat_zone_1
    icon: "mdi:thermostat"
    device_class: heat
    filters:
      - delayed_on_off: ${debounce_time}
    on_press:
      then:
        - if:
            condition:
              switch.is_off: bypass_zone_1
            then:
              - switch.turn_on: relay_zone_1
              - logger.log:
                  format: "${zone_1_name} thermostat: HEAT ON"
                  level: INFO
            else:
              - logger.log:
                  format: "${zone_1_name} thermostat pressed but BYPASS ACTIVE - command ignored"
                  level: DEBUG
    on_release:
      then:
        - if:
            condition:
              switch.is_off: bypass_zone_1
            then:
              - switch.turn_off: relay_zone_1
              - logger.log:
                  format: "${zone_1_name} thermostat: HEAT OFF"
                  level: INFO
            else:
              - logger.log:
                  format: "${zone_1_name} thermostat released but BYPASS ACTIVE - command ignored"
                  level: DEBUG

  # ZONE 2 THERMOSTAT INPUT
  - platform: gpio
    pin:
      number: ${thermostat_zone_2_pin}
      mode: INPUT_PULLUP
      inverted: true
    name: "${zone_2_name} Thermostat Call"
    id: thermostat_zone_2
    icon: "mdi:thermostat"
    device_class: heat
    filters:
      - delayed_on_off: ${debounce_time}
    on_press:
      then:
        - if:
            condition:
              switch.is_off: bypass_zone_2
            then:
              - switch.turn_on: relay_zone_2
              - logger.log:
                  format: "${zone_2_name} thermostat: HEAT ON"
                  level: INFO
            else:
              - logger.log:
                  format: "${zone_2_name} thermostat pressed but BYPASS ACTIVE - command ignored"
                  level: DEBUG
    on_release:
      then:
        - if:
            condition:
              switch.is_off: bypass_zone_2
            then:
              - switch.turn_off: relay_zone_2
              - logger.log:
                  format: "${zone_2_name} thermostat: HEAT OFF"
                  level: INFO
            else:
              - logger.log:
                  format: "${zone_2_name} thermostat released but BYPASS ACTIVE - command ignored"
                  level: DEBUG

  # ZONE 3 THERMOSTAT INPUT
  - platform: gpio
    pin:
      number: ${thermostat_zone_3_pin}
      mode: INPUT_PULLUP
      inverted: true
    name: "${zone_3_name} Thermostat Call"
    id: thermostat_zone_3
    icon: "mdi:thermostat"
    device_class: heat
    filters:
      - delayed_on_off: ${debounce_time}
    on_press:
      then:
        - if:
            condition:
              switch.is_off: bypass_zone_3
            then:
              - switch.turn_on: relay_zone_3
              - logger.log:
                  format: "${zone_3_name} thermostat: HEAT ON"
                  level: INFO
            else:
              - logger.log:
                  format: "${zone_3_name} thermostat pressed but BYPASS ACTIVE - command ignored"
                  level: DEBUG
    on_release:
      then:
        - if:
            condition:
              switch.is_off: bypass_zone_3
            then:
              - switch.turn_off: relay_zone_3
              - logger.log:
                  format: "${zone_3_name} thermostat: HEAT OFF"
                  level: INFO
            else:
              - logger.log:
                  format: "${zone_3_name} thermostat released but BYPASS ACTIVE - command ignored"
                  level: DEBUG

  # ZONE 4 THERMOSTAT INPUT
  - platform: gpio
    pin:
      number: ${thermostat_zone_4_pin}
      mode: INPUT_PULLUP
      inverted: true
    name: "${zone_4_name} Thermostat Call"
    id: thermostat_zone_4
    icon: "mdi:thermostat"
    device_class: heat
    filters:
      - delayed_on_off: ${debounce_time}
    on_press:
      then:
        - if:
            condition:
              switch.is_off: bypass_zone_4
            then:
              - switch.turn_on: relay_zone_4
              - logger.log:
                  format: "${zone_4_name} thermostat: HEAT ON"
                  level: INFO
            else:
              - logger.log:
                  format: "${zone_4_name} thermostat pressed but BYPASS ACTIVE - command ignored"
                  level: DEBUG
    on_release:
      then:
        - if:
            condition:
              switch.is_off: bypass_zone_4
            then:
              - switch.turn_off: relay_zone_4
              - logger.log:
                  format: "${zone_4_name} thermostat: HEAT OFF"
                  level: INFO
            else:
              - logger.log:
                  format: "${zone_4_name} thermostat released but BYPASS ACTIVE - command ignored"
                  level: DEBUG

# =====================================================================
# INTERVAL - Auto-disable zone bypasses on timeout
# =====================================================================
interval:
  - interval: 30s
    then:
      # Check Zone 1 bypass timeout
      - if:
          condition:
            lambda: |-
              if (!id(bypass_zone_1).state) return false;
              unsigned long elapsed = millis() - id(bypass_enable_time_zone_1);
              return elapsed >= id(bypass_timeout_ms);
          then:
            - logger.log:
                format: "${zone_1_name} zone bypass timeout expired - disabling"
                level: WARN
            - switch.turn_off: bypass_zone_1
      # Check Zone 2 bypass timeout
      - if:
          condition:
            lambda: |-
              if (!id(bypass_zone_2).state) return false;
              unsigned long elapsed = millis() - id(bypass_enable_time_zone_2);
              return elapsed >= id(bypass_timeout_ms);
          then:
            - logger.log:
                format: "${zone_2_name} zone bypass timeout expired - disabling"
                level: WARN
            - switch.turn_off: bypass_zone_2
      # Check Zone 3 bypass timeout
      - if:
          condition:
            lambda: |-
              if (!id(bypass_zone_3).state) return false;
              unsigned long elapsed = millis() - id(bypass_enable_time_zone_3);
              return elapsed >= id(bypass_timeout_ms);
          then:
            - logger.log:
                format: "${zone_3_name} zone bypass timeout expired - disabling"
                level: WARN
            - switch.turn_off: bypass_zone_3
      # Check Zone 4 bypass timeout
      - if:
          condition:
            lambda: |-
              if (!id(bypass_zone_4).state) return false;
              unsigned long elapsed = millis() - id(bypass_enable_time_zone_4);
              return elapsed >= id(bypass_timeout_ms);
          then:
            - logger.log:
                format: "${zone_4_name} zone bypass timeout expired - disabling"
                level: WARN
            - switch.turn_off: bypass_zone_4

# =====================================================================
# STATUS LED - Hardware indicator for system state
# =====================================================================
status_led:
  pin:
    number: ${status_led_pin}
    inverted: false

